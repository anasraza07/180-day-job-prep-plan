Explore krne waalay topics:
- floats and clear fix in CSS
- tracks in CSS Grid
- Resolving Conflicts in Git Deep Dive
- css animation tutorial 12 (after learning JS)
- :target, :notlexbox pseudo class in CSS
- video left from oop in JS Basics
- day 10, 11 & 12 coding section is left + day12 some topics of js is also left
- css responsiveness kewin powell course

Day 01 - HTML Basics: (Traversy Media)
- HTML = markup language for creating webpages / documents, building blocks of the web.
- index.html = root / home page of a website
- ctrl + u => shortcut to see tha source code
- chrome tools are really helpful
- Block level elements = div, h1-h6, p, form
- Inline level elements = span, img, a, input, label
- <strong>, <em> tags are semantic tags used to bold or emphasize the text
- Tag attributes = provide information about an element
- <ul> tag has padding-left of 40px by default
- Unordered list = usually used for website navigation like at navbar
- Tables = pehle use hote thay 1999s mein for website layout but ab ye recommended nhi hain, ab sirf kisi tabular data ke liye use kiye jaate hain html mein
- Form mein jo attributes hain like action aur method, action mein koi file ya server ka address dete hain jahan form data recieve hote hai aur method mein "POST" ya "GET" dete hain yaani POST for safe data and GET for searching data bcuz it is not safe, data url mein nazar aata hai
input name attribute = ye bhi server side programming mein use hota hai like jo data server pr jaayega wo usi naam se jaayega jo is name attribute mein dengay ham
Semantic tags = clearly describe its meaning to both the browser and the developer, they are: <header>, <footer>, <aside>, <main>, <article>, <nav>, <section> and <details>.
<small> tag is usually used for create dates like sub content

Day 02 - CSS BASICS (Traversy Media)
CSS = used for website layout and design, can be extended with Sass/Less

Day 03 - CSS FLEXBOX (Net Ninja & Self Revision)
- flex-grow = we use it to expand elements into available space by giving each flex item a growth rate
- flex-shrink = we use it to shrink elements as the browser gets smaller by giving each flex item a shirnk rate
- by default, flex items shrink in proportion to one another at same rate
flex-basis = minimum width ki tarh kaam krta hai aur same tarh behave krta hai, inital width set krta hai items ki, bs eik farq hai ke minimum width dene pr shrink krne se horizontal scrollbar aata hai jabke flex-basis ka use krke shrink krne se items shrink hojaate hain 
- minimum width use krke flex grow: 1; krne se sb items grow krke same hojaate hain jabke flex-basis use krke flex-grow: 1; krne se items inital width ke hisaab se hi grow krte hain
flex-flow = shorthand for flex-direction and flex-wrap
order = default value 0 hoti hai aur agr 0 value khud se di to source code ke according items order hongay, jitni lowest value wo item pehle aayega aur highest order waala item last mein aayega
- Sometimes reversing the row or column order of a container is not enough. so in those cases, we can apply order property to individual items. By default, items have a value of 0, but we can use this property to also set it to a positive or negative integer value (-2, -1, 0, 1, 2).
- align-self = Another property you can apply to individual items, it accepts the same values as align-items for the specific item.
- align-content = to set how multiple lines are spaced apart from each other. value: flex-start, flex-end, center, space-between, space-around, space-evenly, stretch (default). It determines the spacing between lines, while align-items determines how the items as a whole are aligned within the container. When there is only one line, align-content has no effect.
- flex-grow by default 0 hota hai aur flex-shrink by default 1 hota hai
- flex = shorthand property hai grow, shrink aur basis ki
- jese hi ham display flex krte hain so container apne items ko shrink krta hai as smallest as possible because flex-items mein by default shrink 1 aur grow 0 hota hai
- flex-grow: 1; krne se item saari available space le leta hai

Day 04 - CSS Grid (Net Ninja & Self Revision)
- grid rows = automatically create hoti hain when we have content aur column fix hote hain so phr nayi row mein content shift hojaata hai
- grid-auto-rows = container ki property hai jiska use krke ham tamam grid items ki height set krte hain, is mein minmax bhi use kr skte hain
- align-items & justify-content = container property hai jo saaray items ki alignment ke liye use krte hain aur content jitni space le kr items align hojaate hain
- grid-column-start = specifies start position of grid item within grid columns. value: <integer>, span <integer>. When grid-column-start is used alone, grid item by default will span exactly one column
- you might assume that the end value has to be greater than the start value. But this turns out not the case!
- If you want to count grid lines from the right instead of the left, you can give grid-column-start and grid-column-end negative values. For example, you can set it to -1 to specify the first grid line from the right.
- span keyword = you can also define grid item based on your desired column width using the span keyword. Keep in mind that span only works with positive values.
- grid-column is a shorthand property that can accept both (start and end) values at once, separated by a slash.
- grid area = If typing out both grid-column and grid-row is too much for you, it is yet another shorthand for that. grid-area accepts four values separated by slashes: grid-row-start, grid-column-start, grid-row-end, followed by grid-column-end.
- order = all grid items have an order of 0, but this can be set to any positive or negative value, similar to z-index.
- fr = Grid also introduces a new unit, the fractional fr. Each fr unit allocates one share of the available space. For example, if two elements are set to 1fr and 3fr respectively, the space is divided into 4 equal shares; the first element occupies 1/4 and the second element 3/4 of any leftover space.
- When columns are set with pixels, percentages, or ems, any other columns set with fr will divvy up the space that's left over.
- grid-template-rows har waqt set krna recommended nhi hai balke columns set krne ke baad grid automatically rows create krta hai content ke hisaab se
- grid-auto-columns and grid-auto-rows means any automatically generated rows aur columns ka kia size rkhna hai wo batao

Day 05 - Design in CSS (Kevin Powell)
- by default things are responsive, agr sirf html code hai aur eik line css ki nhi hai tb bhi wo website responsive hogi, hn thori ajeeb dikhegi but hogi responsive
- css mein values de kr ham khud responsive khatam krte hain, so by default responsive hoti hai 100% width ki waja se on all block level elements, so that's why while creating layout we should never use fixed width (like in pixels) for parent element.
- and for child element also we should never use fixed width bcuz is se overflow issue aajata hai, content overflow hota hai
- height kabhi nhi deni chahiye is a general suggestion
- the web wants to be responsive with css, ham isko non responsive banaate hain
- so ham height ki jaga padding use kr skte hain jis se layout responsive rehta hai
-em unit font-size mein dia jaata hai so apne parent se relate krta hai yaani parents mein agr kisi ka font size hai to usi ke according work krta hai, but agr kisi parent ka font size nhi hai so body ka 16px ke according work krta hai, its like compounding.
- aur agr kisi aur css property mein em unit use kia to wo usi element ke font-size se relate krta hai
-rems unit are always looking for root, so ye compounding ka issue solve krti hai aur html ke font-size se relate krta hai ye rem unit
- so rem unit consistency ke liye use hota hai aksar
- for font size we should use rems, and em unit for margin (jo lock naa krni ho like margin-bottom) and padding, wrna margin ke liye bhi rem use kr skte hain if we want consistent margin
- width ke saath ham use krte hain max-width for better design on big screen so is se text aur content poora stretch nhi hota from left to right, balke eik specific size pr ruk jaata hai
- height ki tarah min-width bhi zaada use nhi krte bcuz is se bhi issues aa skte hain responsiveness mein, so jahan bht need ho wahi use krna chahiye
flex items = apni width ko kam se kam rkhne ki koshish krte hain yaani content ke hisaab se hi, taakay eik row mein sb fit hojaayen, zaada se zaada 100% width bhi hoti hai if there is only one flex item
- so ham flex items ko 100% de skte hain so that agr content kam bhi hojaye width kam naa ho
- gap property for flexbox use nhi krni chahiye bcuz ye sirf firefox pr sahi chalti hai, so iski jaga ham + combinator selector ka use krte hain
"+" combinator selector = adjacent sibling dekhta hai before element
- flexbox by default apne items ki height stretch krke rkhta hai
- justify-content: space-between; ke liye zaroori hai ke ham items ki width kch naa kch kam rkhen jbhi property work karegi
- img ko responsive banaane ke liye hamesha max-width: 100% use karen thats it
- grid is for structured layout, while flexbox is for intrint sizing
- both can work same for us
- grid kaafi easy to start hai so isliye thora better rehta hai
- kisi element ko to the right bhejne ke liye css handy trick: 
margin-left: auto; krdo is se eik dam right pr chala jaata hai element
- isi tarh gap ke bagair elements ke beech space dene ke liye:
.item + .item { margin-left: 1em }; use kr skte hain jis se corners waale element disturb nhi hongay

Git Deep Dive (Traversy Media)
Topics:
Git Version Control
Subtopics:
Commits
Branches
Merging
Remote Repositories

Git = eik distributed Version Control system (vcs) hai jo developers ki help krta hai unke codebase track krne mein, eik doosre ke sth collaborate krne mein aur project ke multiple versions manage krne mein. In simple words it is used to backup your code. It is decentralized (means you dont need a central server)
Github = web based platform hai jo version control aur collaboration ke liye use hota hai. Repositories host krta hai aur eik interface provide krta hai code manage krne ke liye aur bhi bht kch krta hai

branching = koi naya feature ya bug fixing pr kaam krne ke liye hamain allow krta hai without affecting main codebase, aur phr jb ham ready hon so apne kaam ko merge kr skte hain

to completely delete .git file = rm -rf .git
"U" and green color in vs code files shows = untracked (not added in staging area)
"A" shows = added
"M" shows = modified

git log = command that shows commits starting from most recent
and "q" to quit from it

shortcut command to add and commit at a same time = git commit -am "commit msg"
another thing you can do is = git add . && git commit -m "added task 7"

Explore: what is SSH keys and difference b/w http and ssh while git clone

create and switch to that branch = git checkout -b feature/login
- feature/login and bugfix/responsiveness are naming conventions

switch to branch = git checkout main
delete branch locally = git branch -d feature/login
to merge branch = git merge feature/login

vercel se ham github repo ke through cicd yaani continuous integration aur continuous deployment kr skte hain yaani code push krdo aur deploy krdo first time, ab jb bhi code push hoga website update hoti rahegi 

Day07 - CSS Variables
Topics:
Custom Properties
Dynamic Styling
Inheritance

css Variables DOM ka access rkhte hain so that javascript ke through ham change kr skte hain, media queries ke according change kr skte hain eik hi jaga, themes ke liye use kr skte hain
:root eik pseudo class hai jo root element ko point krti hai basically our html element
- overriding css Variables = ham ye bhi kr skte hain jese root mein Variables define krne ke baad usi Variable ki value kisi div ya seciton ke andr change kr skte hain jis se us section mein values alag apply hongi aur poore root yaani html mein alag values apply hongi, ye bhi bht useful hai
local Variable = isi tarh se ye local Variables hote hain jo bilkul first time root mein nhi balke kisi tag mein ham likhte hain aur wo local Variable kahi aur work nhi karega except that tag
- isi tarh ham css Variables ko themes ke liye use kr skte hain just like eik class dekr us class mein kch Variables set krliye aur phr wo specific section ya koi bhi element hai wo eik alag tarh dikhaayi deta hai
Update Variables with javascript = ham change bhi kr skte hain like root element ko get krke us mien jo Variables hain uski values change krdi so ye sb website mein font size change krne ke liye ya themes pick krne ke liye use hota hai
Variables with media queries = ham media query define krke bhi Variable ki value change kr skte hain
Inheritance issues = Variables agr hamne declar kiye aur uski value bhi eik Variable hai to wohi save hojayega, ab aesa nhi hoga ke wo value waala Variable change krne pr ye current Variable bhi change hojaaye
- isi tarh inheritance issues aate hain specially referencing mein ke css Variable ki value hi inherit krta hai naa ke value mein saved Variable.
It means css Variables referencing nhi krta, only value save krleta hai

Day 08 - CSS Animations
Topics:
Keyframes
Transitions
Tranform
Animation properties

transform = web elements ko transform krta hai jese stretch, rotate, change their coordinates, skew krna ye sb ke liye transform property use hota hai
translate = transform ki eik value hai jo move krti hai elements ko from one position to another
scale = transform ki another value hai use to make elements bigger or smaller, 1 is default value
rotate = transform ki value hai jo x aur y ke sth nhi balke z ke sth zaada sahi dikhti hai rotateZ zaada sahi lagta hai
transition = property hai jo css properties ko transition krti hai taake web elements foran change naa hon eik slow-mo jesa look aaye
transition property syntax = property-name duration delay timing-function
Keyframes = iske through ham animations define krte hain different tareeqay se jese sbse simplest method hai from and to waala yaani from se to tk animate kro, yahan animation define krke phr element ko as a property animation name de dete hain
animation-fill-mode = ye pop up se rokta hai jese animation end krne pr element again apni default value pr aaajata hai jo acha nhi lata isko set krne liye ye property use hoti hai with forwards value yaani animate ke baad ab wahi rahay, isi tarh agr animation ke from mein kch alag position hai so again pop up krta hai iske liye value backwards use krte hain, so in short ham both bhi use krte hain for better results
repeating animations = ye ham krte hain using animation-iteration-count jisko bataate hain ham ke kitni baar animation run krni hai
animation-direction = ye direction change krta hai jese reverse mein sirf animaiton reverse chalegi, alternate mein from se to aur to se from again and again animation chalegi, jbke alternate-reverse mein same hi hai sirf wo to se start hogi animation ye difference hai
animation-timing-function = ye speed ke liye use krte hain ham, default value iski ease hoti yaani slow fast slow, ham different values de skte hain aur apna custom bhi define kr skte hain jese https://cubic-bezier.com website hai wahan jaakr 
animaiton shorthand = is mien order matter nhi krta but sbse pehle jo number hai wo hamesha duration ka hoga aur iske baad waala delay ki value hogi
- from aur to 2 states hain so jahan 2 states ke liye use krna ho wahan ye use hota hai wrna is se zaada changes ke liye percentages use krte hain
animaiton chaining = yaani eik aur animaiton eik sth same element ko thora saa delay de kr de skte hain so isko animaiton chaining kehte hain
transform-origin = is property se ham origin bhi define kr skte hain element ka ke kahan se turn hona hai ya rotate krna hai etc etc.

Day 09 - CSS Pseudo-classes 
Topics:
:hover,
:focus,
:nth-child
styling interactions. 

Pseudo-class = is used to define a special state of an element. jese 
:disabled pseudo class = hamain allow krta hai disabled elements pr style lagaane ke liye
:first-child = jo bhi element first ho apne siblings mein chaahe wo kahi bhi poori body pr wo select hojaata hai aur ham styles apply kr skte hain, isi tarh :last-child aur :nth-child work krte hain.
:nth-child = :nth-child(2), :nth-child(2n), :nth-child(even), :nth-child(odd) ye sb ke sth kaam krta hai
:first-of-type = means koi element jo first hai yaani first p ya first h1 poori body pr wo select krke usko styles apply kr skte hain
pseudo-classes for links = eik to hai :link for unvisited, doosra hai :visited for visited links, teesra hai :hover for mouse over, fourth hai :active for click elements
- Use :link to style links to unvisited pages, 
:hover to style links when you mouse over them, and 
:active to style links when you click on them.
- To style links appropriately, put the :visited rule after the :link rule, but before the :hover and :active rules. So the order should be
:link {}
:visited {}
:hover {}
:active {}
Allowed styles in visited pseudo-class:
- color
- background-color
- border-color (and border-color for separate sides)
- outline color
- column-rule-color
- text-decoration-color
- text-emphasis-color   
- SVG attributes fill and 

Day 10 - CSS Box Model & Landing Page

Day 11 - Responsive Images & Review
pexels = site for best images
smartmockups = for mockups

Day 12 - JavaScript Basics (Traversy Media)
Topics: variable, data types, conditionals, console.log
- always use const unless you know you are going to reassign the value
- const use krke ham Variable initialize bhi nhi kr skte, koi value assign krni parti hai
- let & const = have a block level scope 
- primitive data types = directly assigned to memory  
- null means basically empty
- why typeof null is object? is this wrong? why it gives wrong value? = starting mein jab JavaScript pehli baar bana tha, toh usmein values ko ek khaas tarah se store kiya jaata tha, jise "type tag" kehte hain. object ka type tag 000 tha. Null ko us waqt ek "null pointer" ke taur par represent kiya gaya tha, jiska value bhi 000 hi hota tha. Is wajah se, jab typeof operator null ko check karta tha, toh usko lagta tha ke yeh bhi ek object hai, kyuki dono ka type tag same tha. 
- Ab isko theek kyun nahi karte? = JavaScript ab duniya mein har jagah istemaal hota hai. Agar is ghalti ko ab theek kar diya jaaye, toh bohot saari purani websites aur applications kaam karna band kar dengi. Is problem ko "backward compatibility" ke liye waisa hi chhor diya gaya hai, taake purana code ab bhi sahi kaam kare. Is masle se bachne ke liye, typeof ki jagah hamesha === ka istemaal karen.
- value === null ka matlab hai ke value aur null dono bilkul barabar hain, baghair kisi ghalti ke.
- typeof value === 'object' istemaal karna tab sahi hai jab aap ko maloom ho ke value null nahi ho sakti. 
- mehtod = is a function that is associated with an object
- .split("") = method hai jo string ke hr character ko alag alag element banaa kr array return krta hai if empty string, wrna iske apne hisaab se split kr skte hain based on jo bhi quotation ke andr ho
- typescript = is a superset of javascript, its basically javascript with some added features like static typing (variables ka type bhi define krna prta hai)
- .substring(0, 5) = string ke 0 index se start karega aur 5 se pehle stop krke characters return krdega    
- Array.isArray(arrName) = check krne ke liye ke ye chz array hai ya nhi, aur phr return mein boolean value milti hai
- .indexOf(element) = kisi element ka index check krna ho tb use krte hain ye method
- JSON = is a data format used a lot in fullstack development when 
sending data to the server or recieving from server usally in json format and it is very similar to object literals 

Day 13 - JavaScript Loops
Topics: for, while, forEach, loop control (break, continue) 
- break keyword = we can use it to break out of the loop at any point
- continue keyword = we use it to just skip out the code for that iteration

Day 14 - JavaScript Functions 
Topics: declarations, expressions, parameter, return statements
- paramter = something that we pass to a function while declaring or defining the function.
- argument = the actual value we pass to the function while calling or invoking it.
- function with parenthesis = executing, calling, invoking the function
- function without parenthesis = is the string representation of the function definition itself
- rest paramter = allows a function to accept an infinite numbers of arguments as an array. Function definition can have only 1 rest paramter and the rest paramter must be the last paramter
- closure = the inner function, means the nested function is clousre thats it, simple definition.
- inner function = can access the outer function's argument or any Variable that is declared in outer function
- wese to hr function jese hi execute hota hai to ab iske andr create kiye gaye Variables bhi khatam hojaate hain, lekin closure yehi hai ke outer ke function ke andr banaaye gaye Variable ya iska argument jo hai wo khatam nhi hota even after executing outer function, so isko ham baad mein use kr skte hain ye save rehta hai aur yehi closure hai
- Jab ek function execute hone ke baad bhi uske andar ka variable ya argument memory mein bacha rehta hai, aur usko inner function access kar sakta hai, to is concept ko closure kehte hain.
- Yeh tab hota hai jab inner function outer function ke variables ko use karta hai — even after outer function finish ho jaaye.
- callback function = is the function that we can pass to any function and call this function based on any condition at a later point of time
- higher order funciton (HOF) = a regular funciton that 1. takes one or more funciton as an argument and/or 2. returns a function as a value of it, so koi bhi condition meet krti hai wo funciton higher order funciton kehlaayega
- pure function = is the function that produces the same output for the same input
- impure funciton = opposite of pure function that means for the same input, it is not going to create same output, so it is depending on something which is called side effect.
- side effect = is nothing but the variable which is outside of the scope of a function and function cannot control this particular variable, anyone can change which can create a side effect
- IIFE (immediately invoked function expression) = a funciton expression where the code inside the function gets executed immediately after its been defined
- call stack = when a function gets executed there is a stack that javascript engine maintains and it works like first in last out, jese hi javascript interpreter ko funciton call dikhta hai kisi line pr so us function ko call stack ke andr store krta hai aur execute hone pr stack se nikaal deta hai, so in short call stack means function execution stack
- recursion = means a funciton refer or call itself, recursion use krte hue aapko make sure krna hai ke koi base condition hai jbhi recursion ka sahi use hoga aur sahi work karega. Base condition means under which condition you have to stop recursion

Day 15: JavaScript Arrays
Topics: creation, indexing, length, basic methods (push, pop)

Day 16: JavaScript Objects
Topics: object literals, properties, methods, dot/bracket notation

Best array guide - freecodecamp = https://www.freecodecamp.org/news/javascript-array-tutorial-array-methods-in-js/

Day 17 - Javascript Array Methods: (freecodecamp news article)
deep copy = 1st level data ke sth andar ke nested arrays ya objects bhi alag copy hote hain taakay agr copy mein koi change kro, original safe rahay
shallow copy = sirf 1st level ka data copy hota hai, andar ke nested array ya objects hon to unka reference copy hota hai naa ke actual data
spread operator = shallow copy krta hai
JSON.parse(JSON.stringify(...)) = deep copy krta hai but with some limitations jese: Functions, undefined, symbols, aur Map, Set ko handle nahi karta, Unko skip ya string mein convert kar deta hai.
includes() = agr hamein jaanna ho ke kia ye value array mein exist krti hai tb ham ye method ye use krte hain. Ye 2 parameters leta hai: value, startingIndex. startingIndex by default zero hota hai.
indexOf() = agr aapko index pata krna ho kisi specific value ka, tb ye method use krte hain. Ye sirf first index return krta hai jese jb isko value mil jaaye tb wrna -1 return krta hai. Ye bhi 2 parameters leta hai: value aur startingIndex
find() & findLast() = is se ham array mein first ya last element find kr skte hain jo hamari certain condition satisfy krta ho. Ye dono eik callback funciton lete hain jiske parameters hain: element, index aur array. Ye dono first ya last element return krte hain based on condition wrna undefined agr koi value match naa karay
findIndex & findLastIndex = ye dono bhi same isi tarh kaam krte hain bs farq ye hai ke index return krte hain wrna -1
every() & some() = jb array ke kisi element pr condition lagaa kr check krna ho tb ye methods use krte hain. Ye dono mehtods array pr iterate krte hain aur based on condition boolean value return krte hain jese every() ke liye hr element pr condition true honi chahiye, jakbe some() ke liye eik element pr bhi condition true hogai to true return krdega. Ye dono bhi 3 parameters lete hain: element, index, array.
filter() = array elements ko filter krta hai based on certain condition. callback function leta hai jiske parameters hain: element, index aur array. array ki shallow copy banaata hai jis mein wohi elements hote hain jinke liye cb funciton truthy value return krta hai baaqi ko neglect krdeta hai 
forEach() = kch return nhi krta isliye isko end of chain use krte hain
sort() = array ko sort krta hai, by default kch unexpected outcomes aaskte hain isliye isko callback function pass krte hain so that sorting cb ki return value pr depend krti hai. callback funciton 2 parameters leta hai a and b jo 2 elements represent krta hai, agr return value: positive ho to b ke baad a aayega, negative ho to a ke baad b aayega, 0 ho to original order rahega same
reduce() = ye methods eik callback leta hai jiske parameters hain: accumulator, element, index, array. har iteration ki return value next iteration ko pass hoti hai, second parameter of this methods is the starting value of accumulator, agar ye ham naa den to accumulator array ki 1st value le lega aur iteration second value yaani index 1 se start hogi

Day 18 - Javascript Localstorage
localstorage = web browser ka eik feature hai jo allow krta hai developers ko ke user ke browser mein data save krlo. Ye web storage API ka part hai with session storage. key-value pairs mein data accept krta hai aur save rkhta hai even user page refresh karay ya browser ya tab band krde tb bhi
session storage & difference = is mein jo data save hota hai wo tab/browser ke band hone se clear hojaata hai. Aur ye data speci browser tab ke liye hota hai jo share nhi hota jabke localstorage mein data multiple browser tabs aur windows mein accessible hota hai 
delete data from localstorage = iske 2 methods hain eik hai: removeItem(key) jo key leta hai aur us key value pair ko delete krta hai, aur doosra hai: clear() jo saara data clear krdeta hai 
localstorage.key(0) = ye method key ka name get krne ke liye use krte hain jo index leta hai aur us index pr key ka naam bataata hai, agr koi key naa ho us index pr to null return krta hai
- cookies 5kb per domain data le skta hai jbke localstorage 5mb per domain data store kr skta hai
localstorage guide = https://www.freecodecamp.org/news/use-local-storage-in-modern-applications/

Day 19 - JavaScript DOM
- DOM (document object model) = basically a structured representation of an html document. kind of tree of nodes or elements created by the browser. DOM is object oriented meaning that each node has its own properties and methods
- HTML collection = array jesa dikhta hai but is mien aur array mein ye difference hai ke html collection ke sth ham array ka har method use nhi kr skte iske liye hamein collection ko array banaana prta hai pehle
- innerText aur textContent difference = ye dono hi text ko change krne ke liye use hote hain, difference ye hai ke innerText zaadaa attention deta hai styles pr jese agr kisis element ko display: none; property di to innerText mein bhi wo show nhi hoga lekin textContent mein show hota hai even page se hide hojaata hai tb bhi 
- querySelector = is mein aap koi bhi css selector use krke element select kr skte hain
- nodelist = querySelectorAll ye return krta hai hamain, jis pr ham easily array methods run kr skte hain unlike html collection
- text node = represent white spaces like line break that's why instead of using childNodes, use children and instead of using firstChild, use firstElementChild
- isi tarh lastChild aur lastElementChild method hai, nextSibling aur nextElementSibling method hai, previousSibling aur previousElementSibling hai jo eik text node deta hai aur eik sahi kaam krta hai
- className = kisi bhi element ki classes get krne ke liye yehi use krte hain 
- e.type = bataata hai konsa event hai ye jo abhi trigger hua
- e.clientX & e.clientY = ye mouse ki pisition bataate hain window se
- e.offsetX & e.offsetY = ye mouse ki position usi element se bataata hai jis pr event trigger hua hai
- event.ctrlKey, event.shiftKey & event.altKey = ye boolean value return krte hain like in keys hold krke agr koi event trigger hua to ye methods true return karengay wrna false 
- mouseenter = event hai jo sirf element pr hi trigger hota hai
- mouseover = event hai jo inner elements pr bhi trigger hojaata hai yehi difference baaqi dono eik jese hain
- mouseleave = element ke baahar jaane pr trigger hota hai
- mouseout = element ke baahar jaane pr aur inner element se baahar jaane pr bhi trigger hota hai
- keypress event is deprecated thats why always use keydown event
- keydown event = tab trigger hota hai jab key press hoti hai, lekin us waqt character input field mein add nahi hua hota. Isliye e.target.value purani value return karta hai (jo input ke andar tha key press hone se pehle).
- keypress event = Jab printable character key press hoti hai. No value updated
- keyup event = Jab key chhodi jaati hai (key release hoti hai), updated value milti hai
- input event = Jab input value change hoti hai (real-time typing), yehi best hai updated value milti hai

Day 20 - JavaScript Events (apna college)
- event = the change in the state of an object
- event handling = event generate hone ke baad kch kaam krwaana
- inline event handling = html mein hi hoti hai onclick ya on<eventName> ka use krke, which is not recommended
- event handling in js = btn.onclick = function(){ // handle here }
- agr inline aur js dono mein event handle kia hai to priority js ko hoti hai, inline ko nhi.
- event object = eik special object jo event ki details deta hai
- event listeners = iske through ham same events pr multiple kaam kr waa skte hain, isi liye yehi recommended hai aur yehi use karengay
- the callback reference should be same to remove event listener 
- toggling or toggle button = means 2 state ke beech switch krte rehna

Day 21 - JavaScript ES6 Refactor (Net Ninja)
ecmascript = is a standard for scripting languages, ES5 is current version implemented into most browsers
ES6 = is the latest standardized version of ES, includes many new features but not fully supported in browsers yet
- isiliye kisi live project ke liye aapko transpiler use krna parega like babel or something jo es6 ko es5 mein transpile krta hai 
var and let difference in for loop = var use krne se 1 hi variable har baar overwrite hota hai → loop ke andr sab functions usi variable ko refer karte hain, jabke let har baar naya variable banata hai → loop ke andr har function apna alag variable capture karta hai 
var = function scoped, same variable used in all iterations, Sab closures ek hi variable dikhate hain
let = block scoped (new block per loop), new variable created in each iteration, har closure apna variable dikhaata hai
new string methods in es6 = repeat, startsWith, endsWith, includes
- arrow funciton this ki value bind krdeta hai 
Set = eik naya data structure hai jo ham use krte hain to store unique values of whatever type we want so it means Set eliminate duplicate values, iske apne methods hote hain jo ham use kr skte hain
add(value) = sets ka method hai jo add krne ke baad upated set return krta hai   
delete(value) = set ka eik method hai jo values delete krta hai aur boolean value return krta hai based on deletion, if succeed so it returns true otherwise false. Is mein ham chaining nhi kr skte like add method
clear() = method of set that clear all its elements
has() = array ke includes ki tarh work krta hai aur boolean return krta hai based on value found or not.
Generators = are basically just functions which we can play and pause whenever we want so that we can have ultimate control over the flow of them, ye work is tarh krta hai ke function keyword ke aagay steric (*) lagaado aur phr ab jb function call hoga so code foran run nhi hoga balke function set krta hai generator aur eik iterator return krdeta hai   
iterator in generator = jiske through ham iterate krte hain between of cycle of things by using next method play button ki tarh kaam krta hai, isi tarh ham pause bhi krte hain by using yield keyword in our function anywhere we want, aur JS right to left run krti hai so run krte hue jahan yield keyword aaya wahi code pause hojayega aur next ko dhundega agr nhi hai to pause rahega 
yield keyword = ye help krta hai iterator ko value pass krne mein jese generator function mein yeild ke baad agr koi value pass karen to wo hamein iterator mein return milti hai when we call next method, poora eik object milta hai with value and done property aur ye done property jb tk true nhi hota jb tk generator function end naa hojaaye, isi tarh ham iterator se generator yaani jahan yeild keyword hai wahan value pass kr skte hain using next method aur phr wo value yeild return karega

Day 22 - Javascript Modules
Import/export, ES modules, module patterns.
module in javascript = is just a file containing related code
export keyword = is used to make a variable, function, class or object accessible to other modules. In other words, it becomes a public code.
import keyword = is used to bring in public code from another module.
- If you're importing everything from a module, you should use the asterisk (*) instead of explicitly spelling out all the functions one-by-one.
'as' keyword = We use this to import the public functions into a new object, which in our case is the 'mainfunctions' object. We then access and call the functions we want to use in our program
Default Exports = when you are most likely to use that single function, you simply use the default keyword. you don't have to import the function into curly braces
- If you want to import the default function along with any other functions, you mix the bare 'default' function with other functions in curly braces

Day 23 - Javascript Error Handling
- error handling = is used most when working with data from other sources or user input, it uses the keywords like try, catch, finally and throw
- try statement = lets you test a block of code for errors 
- catch statement = lets you handle the error 
- throw statement = lets you create custom errors 
- finally statement = lets you execute code after try and catch regardless of the result 
- code mein error milte hi program ruk jaata hai aur direct catch statement mein chala jaata hai
- jb error aata hai to JS eik obj banaaleta hai with error details jo catch ke parameter mein accessible hota hai hamein, is obj ki 2 properties bhi hoti hain name aur message; name => yaani referenceError aur message => wohi error msg
- try catch sahi kaam karay iske liye zaroori hai code runnable ho yaani valid javascript ho koi wrong syntax naa ho
- try catch does not handle parse time errors, it only handles runtime errors
- koi error try block se bach nhi skta, pehle error aate hi baaqi instructions execute hone se ruk jaati haina aur try us error value ko pass krdeta hai catch block ke andr
- .finally() ki tarh hi finally block work krta hai
- try catch aur finally block ko async function ke andr use karen

Day 24 - JavaScript RegEx (freecodecamp/learn)
Topic: Patterns, Matching, Validation (email, numbers, etc.)
- As a refresher, here is a regular expression to match the string hello world:
Example Code
const regex = /hello world/;
- flags = Regular expressions can take flags to modify their behavior. For instance, the i flag can be used to make the expression ignore case, causing it to match hello, HELLO, and Hello for the expression /hello/. Flags are added after the trailing slash.
- .match() = Strings have a .match() method, which accepts a regular expression as an argument and determines if the string matches that expression.
.test() method = to test if a string matches the pattern. It returns a boolean value indicating whether or not the string matches the pattern.
- The alternate sequence | can be used to match either the text on the left or the text on the right of the |. 
For example, the regular expression /yes|no/ will match either yes or no.
- .some() method = Arrays have a .some() method. Like the .filter() method, 
.some() accepts a callback function which should take an element of the array as the argument. The .some() method will return true if the callback function returns true for at least one element in the array.
- character class = A character class is defined by square brackets, and matches any character within the brackets. For example, [aeiou] matches any character in the list aeiou. You can also define a range of characters to match using a hyphen. For example, [a-z] matches any character from a to z.
- the + quantifier = this matches one or more consecutive occurrences. For example, the regular expression /a+/ matches one or more consecutive 'a' characters.
- capture group = is a way to define a part of the expression that should be captured and saved for later reference. You can define a capture group by wrapping a part of your expression in parentheses. For example, /h(i|ey) camper/ would match either hi camper or hey camper, and would capture i or ey in a group.
-  you can mark the entire pattern as an optional match using ? quantifier. 
? quantifier = matches zero or one occurrence of the preceding character or group. For example, the regular expression /colou?r/ matches both color and colour, because the u is optional.
- \s character = The \s character class matches whitespace, such as spaces, tabs, and new lines.
- * quantifier = means "match the previous character 0 or more times".
+ quantifier =  means "match the previous character at least one time"
shortcuts for understanding:
* → 0 ya unlimited
+ → 1 ya unlimited
? → 0 ya 1 (optional)
\s → whitespace (space, tab, newline)
(a|b) = capturing group → a ya b match kare
[ab] = character class → ek hi jagah pe a ya b aa sakta hai
- You don't actually need the match value from your capture group, so you can turn it into a non-capturing group. This will allow you to group the characters together without preserving the result.
- To create a non-capturing group in a regular expression =  you can add 
?: after the opening parenthesis of a group. For instance, (?:a|b) will match either a or b, but it will not capture the result.
-  \s doesn't match the beginning or end of the text.
- ^ anchor = This asserts that your pattern match starts at the beginning of the full string
-  you can use the $ anchor to match the end of the string.
- link = https://regex101.com/

Day 25 - JavaScript CRUD Project
- Combine everything you’ve learned so far (DOM, events, arrays, localStorage) to build a real CRUD app.
💻 Coding Task – Note‑Taking App
Build a small, single‑page app that lets users:
- Feature Requirement:
Create => Add a note with title & body
Read => Display all saved notes on page load
Update => Click “Edit” → update content → save
Delete => Remove any note
Persist => Save & load notes with localStorage
- Use addEventListener for buttons
- Use querySelector / innerHTML for rendering
- Keep code modular (functions)
🐞 Debug & Polish
Test create / update / delete after page refresh
Handle empty input (show alert)
No duplicate IDs

Day 26 - JavaScript Debugging & Bug Fixing 🐞🔍 (freecodecamp, xplodivity, tapas adhikary)
Learn how to properly debug JavaScript code like a pro!
🛠 Topics Covered:
✅ Using Browser Dev Tools (Chrome / Firefox)
✅ Setting Breakpoints
✅ Console Logging Best Practices
✅ Common JavaScript Errors and Fixes
- Syntax errors = they are thrown when the JavaScript engine encounters something it can't interpret.
- ReferenceError = is thrown when a non-existent variable is referenced. for example you trying to use math but JavaScript doesn't have a math object.
- TypeError means = that the code is trying to perform an operation on a value that is not of the expected type.
- null = is a special value in JavaScript that represents the absence of a value. This can happen when you try to access a property of an object that doesn't exist.
undefined = when the variable is not being set correctly.
- dark colors = #2C3E50, #34495E, #2C2C2C, #616A6B, #4A235A, #2F4F4F, #0E4B5A, #36454F, #2C3E50, #800020
- breakpoint = is a point of code where debugger will automatically pause the javascript execution and while the code is paused we can examine current variables, execute commands in the console and so on, in other words we can debug it.
- state of our code = state of our local or global variables, it also means the funciton parameters, basically everything we see in the code before breakpoint
- watch section in debugger pane = basically shows current values for any expressions, but hamein pehle add krna prta hai variable ka naam
callstack section = shows the nestes calls chain, basically it shows what funciton currently being run and what funcitons are called from within that function, jb bht saaray functions hote hain to hr function click pr krne se uske variables display hojaate hain scope section mein
scope section = shows you what local and global variables are currently defined, along with the value of each variable
script dropdown in scope = always include let and const variables declared outside the funciton
- var keyword se banne waala variable global hota hai aur global dropdown mein show hota hai, so in browser you can access it as a property of window
- by let and const they dont become global variables, you can access them in another script tag
- so mtlb ye hua let and const ke sth variables even if globally defined ho tb bhi global nhi hain
- global variable sirf var ke sth bnte hain
- resume icon (F8) = execution ko next line mein continue krne ke liye use hota hai yaani next breakpoint pr, jese hi last breakpoint aata hai aur resume krte hain to Debugging end hojaati hai
- step icon (F9) = it basically run the next statement, next line pr step krta hai jis tarh script run krti hai us order mein yaani koi funciton aaya to us funciton ke andr chala jaayega aur phr end hone pr again apni jaga se shuru karega
- step over icon (F10) = nested function mein nhi jaata balke usko run krke next line hi pr aajata hai aur line by line hi run krta hai, but funciton execute zaroor hota hai bina us function ke andr jaaye (ye yaad rkhna hai)
- step command ignores the async actions, but step into icon ignore nhi krta
- step into (F11) = goes into code waiting for any async action if necessary
- step out (shift + F11) = continues the execution till the end of current function, aur ye tb kaam aata hai jb ham accidently kisi function call ke andr enter hojaayen by using step icon aur hamein us se baahar nikalna ho as soon as possible
- debugging = the process of tracking a bug or a issue
- fixing = the removal of the bug once you debug and find it
- conditional breakpoints = bhi ham set kr skte hain jese agr expression "john" ho to pause hojaao
- event listeners aur dom breakpoints bhi lagaa skte hain ham using dev tools
- debugger keyword = iska use krke bhi ham direct pause lagaa skte hain jis pe wo debugger keyword waali line pr hi pause karega (but not recommended)
- workspace = jb hamein fix krna ho dev tools ke andr hi aur save bhi krna ho so wohi changes automatically reflect karen vscode mein iske liye ham workspace use krte hain
- file ke sth * sign means = file save nhi hui so save it using ctrl + s
- vscode se bhi ham dev tools ki tarh debugging kr skte hain, sirf thori se configuration krni prti hai bs phr saara same setup create hojaata hai
Debugging Tips:
1. accept
2. bigger picture
3. debug other's code
4. discuss
5. tools
6. take a break
7. dont giveup

Day 27 - JavaScript Review + Start Portfolio
🧠 Focus Areas: Review core JS concepts -> Variables, Loops, Functions, DOM manipulation, Events and then Start building your Portfolio Website

Day 28 - CSS Review – Layouts & Best Practices
Add: Navbar with logo & links, Footer with your GitHub/LinkedIn, ✅ Responsive layout using Flexbox and Grid
- we can use CSS to make elements completely hidden from the visual page, but still be announced by screen readers.
- span[class~="sr-only"] = selector will select any span element whose class includes sr-only
- CSS clip property = is used to define the visible portions of an element. 
- clip property of rect(1px, 1px, 1px, 1px).
- clip-path property = determines the shape the clip property should take. 
- clip-path property to the value of inset(50%), forming the clip-path into a rectangle within the element.
- To prevent the text content from overflowing, we can give an overflow property set to hidden and a white-space property set to nowrap.
- when you need to take hidden elements out of the document flow give a position property set to absolute, a padding property set to 0, and a margin property set to -1px. This will ensure that not only are they no longer visible, but they are not even within the page view.
- The :first-of-type pseudo-selector = is used to target the first element that matches the selector.
- Adding position sticky moved the element into its own stack. To ensure your element does not get hidden by different stacks, add a z-index property set to 999.
- The span[class] syntax will target any span element that has a class attribute set, regardless of the attribute's value.
- The :not() pseudo-selector = is used to target all elements that do not match the selector 
- span:not(.sr-only) = any of your span elements that do not have the sr-only class.
- Rather than having to constantly double-check you are not overwriting your earlier properties, you can use the !important keyword to ensure these properties are always applied, regardless of order or specificity.
-  border-collapse property to collapse = will allow cell borders to collapse into a single border, instead of a border around each cell.
- Give a width to fill the viewport, with a minimum and maximum of 4rem. This approach ensures that the width is fixed, whereas setting width specifically would allow the elements to shrink to the container.
- The key difference between tr[class="total"] and tr.total is that the first will select tr elements where the only class is total. The second will select tr elements where the class includes total.

Day 29 - HTML Review – Structure, Semantics & Accessibility
Topics: Master clean and semantic HTML, enhance accessibility, and build more pages for your portfolio site. Add About page (your journey, goals) Add Projects page (your apps like quiz app, notes app, etc.) Use semantic tags: <section>, <article>, <nav>, <main>, etc. Use accessible HTML practices 
(e.g., <label>, alt, headings order) Ensure site works with keyboard only (for accessibility check) Use browser accessibility tools (Lighthouse)
- lang attribute to your html element = will assist screen readers in identifying the language of the page.
- meta element = used to specify information about the page, such as the title, description, keywords, and author.
- a viewport definition = tells the browser how to render the page. Including one betters visual accessibility on mobile, and improves SEO (search engine optimization).
- description definition = important meta element for accessibility and SEO
- title element = useful for screen readers to understand the content of a page. Furthermore, it is an important part of SEO.
- Navigation is a core part of accessibility, and screen readers rely on you to provide the structure of your page. This is accomplished with semantic HTML elements.
- max function = of css which returns the largest of a set of comma-separated values. For example:
img {
  width: max(250px, 25vw);
}
- In the above example, the width of the image will be 250px if the viewport width is less than 1000 pixels. If the viewport width is greater than 1000 pixels, the width of the image will be 25vw. This is because 25vw is equal to 25% of the viewport width.
- The child combinator selector ">" = used between selectors to target only elements that match the second selector and are a direct child of the first selector. can be helpful when you have deeply nested elements and want to control the scope of your styling.
- role = To increase the page accessibility, the role attribute can be used to indicate the purpose behind an element on the page to assistive technologies. The role attribute is a part of the Web Accessibility Initiative (WAI), and accepts preset values.
- Every region role requires a label, which helps screen reader users understand the purpose of the region. One method for adding a label is to add a heading element inside the region and then reference it with the aria-labelledby attribute.
- Typeface plays an important role in the accessibility of a page. Some fonts are easier to read than others, and this is especially true on low-resolution screens.
- use Verdana or another web-safe font in the sans-serif family 
- Keeping in mind best-practices for form inputs, give each input an appropriate type and name attribute.
- adding placeholder = is actually not a best-practice for accessibility; too often, users confuse the placeholder text with an actual input value - they think there is already a value in the input.
- so using label is the best-practice. 
- There is a common pattern to visually hide text for only screen readers to read:
position: absolute;
width: 1px;
height: 1px;
overflow: hidden;
clip: rect(0, 0, 0, 0);
clip-path: inset(50%);
white-space: nowrap;
- footer element = is a container for a collection of content that is related to the page, 
- address element = is a container for contact information for the author of the page. it does not have to contain a physical geographical location. It can be used to provide a link to the subject.
- On the topic of visual accessibility, contrast between elements is a key factor. so the contrast between the text and the background of a heading should be at least 4.5:1.
- certain types of motion-based animations can cause discomfort for some users. In particular, people with vestibular disorders have sensitivity to certain motion triggers.
The @media at-rule = has a media feature called prefers-reduced-motion to set CSS based on the user's preferences. It can take one of the following values: reduce or no-preference
- Example Code:
@media (feature: value) {
  selector {
    styles
  }
}

Day 30 - Portfolio & SEO Mastery
Topics: Create a professional, SEO-friendly developer portfolio and deploy it publicly.

Day 31 - Async/Await & Weather App API
Topics: Understanding async/await, Promises, and working with APIs in JavaScript. Build a simple weather app using OpenWeatherMap API, Input: city name. Output: show city’s temperature, weather condition, etc. Handle errors (e.g., city not found)
- If you want data from an online source, you need use an API (Application Programming Interface). An API lets people from outside of an organization retrieve its internal data.
- fetch = a method that allows code to receive data from an API by sending a GET request. Here is how you can make a GET request with the fetch() method:
- Example Code:
fetch("url-goes-here")
- Promise = The fetch() method returns a Promise, it is a placeholder object that will either be fulfilled if your request is successful, or rejected if your request is unsuccessful.
- If the Promise is fulfilled, it resolves to a Response object, and you can use the .then() method to access the Response.
- Here's how you can chain .then() to the fetch() method
Example Code:
fetch("sample-url-goes-here")
  .then((res) => res)
- The data you get from a GET request is not usable at first. 
- .json() = To make the data usable, you can use the .json() method on the Response object to parse it into JSON. If you expand the Prototype of the Response object in the browser console, you will see the .json() method there.
- In order to start working with the data, you will need to use another .then() method. Chain another .then() to the existing .then() method. This time, pass in data as the parameter for the callback function.
- .catch() = method is another asynchronous JavaScript method you can use to handle errors. This is useful in case the Promise gets rejected.
- Chain .catch() to the last .then(). Pass in a callback function with err as the parameter. Inside the callback, use console.error() to log possible errors to the console with the text `There was an error: ${err}`
- Note: catch is the last call chained on to fetch, so you can terminate your code with a semicolon.
- if there's an error and the data fail to load, then we need to show an error in the UI. That's exactly what the .catch() method is for – handling errors.
- asynchronous = request data from an API is known as an asynchronous operation, which means that tasks execute independently of the main program flow. You can use the async keyword to create an asynchronous function, which returns a promise. Example Code:
const example = async () => {
  console.log("this is an example");
};
- async function jo kch bhi return krta hai wohi resulting promise ki resolve value ban jaati hai, wrna undefined
- try...catch statement = to handle erros, try block is designed to handle potential errors, and the code inside the catch block will be executed in case an error occurs. Example Code
try {
  const name = "freeCodeCamp";
  name = "fCC";
} catch (err) {
  console.log(err); // TypeError: Assignment to constant variable.
}
- we used fetch() with the .then() method to perform logic after the promise was resolved. But we can also use the await keyword to handle the asynchronous nature of the fetch() method.
- await keyword = waits for a promise to resolve and returns the result. promise se pehle isko place krte hain aur ye async function ke liye eik indicator hai ke pause hojao jb tk promise settle naa ho. Example Code:
const example = async () => {
  const data = await fetch("https://example.com/api");
  console.log(data);
}
- the timeAgo function should meet the following requirements:
1. If the amount of minutes that have passed is less than 60, return the string "xm ago". x will represent the minutes.
2. If the amount of hours that have passed is less than 24, return the string "xh ago". x will represent the hours.
3. Otherwise, return the string "xd ago". x will represent the days.
- Here are some equations that will help you calculate the time difference:
minutes = Math.floor((currentTime - lastPost) / 60000);
hours = Math.floor((currentTime - lastPost) / 3600000);
days = Math.floor((currentTime - lastPost) / 86400000);

Day 32 – JavaScript Promises
Topics: Creating, resolving, and chaining Promises. Refactor async app with
.then() and .catch(). Change yesterday’s weather app from async/await to use: .then() for handling success, .catch() for handling errors, chaining multiple .then() if needed
- JavaScript widely known for its major features: it is single-threaded, non-blocking, and asynchronous.
- single threaded = it means the language can execute only one instruction at a time. This differs from multi-threaded programming languages that run multiple instructions at once.
- non-blocking = it means that the language does not wait for a specific previous instruction to finish executing before it moves to the next one. This ensures that no instruction blocks the execution of subsequent instructions.
- If a programming language is not non-blocking, it could lead to slow applications.
- asynchronous = means that javascript can handle a large number of tasks at a time. This is a feature of multi-threaded programming languages, but JavaScript achieves it with a single thread.
- Multi-threaded programming = a program can be split into separate threads, with each executing independently of the others.
- For a browser to interpret JavaScript code, it needs to have a JavaScript engine.
- JavaScript step by step, top to bottom execute hoti hai, pehle pehla task, phir doosra, phir teesra...
- For a browser to interpret JavaScript code, it needs to have a JavaScript engine. 
- js engine = is a software component of a modern web browser that accepts JavaScript code, analyzes it, and transforms it into instructions the device will understand. Different engines have individual differences, but their jobs still remain the same. They process JavaScript Code.
- JavaScript runtime = is the environment that contains all the resources necessary for the execution of a JavaScript program. It includes the JavaScript Engine but also includes other things.
- call stack = is a component of a JavaScript Engine that keeps track of all the functions the program executes. It is a Stack data structure that operates with two key operations: 1. Push: adds or pushes a new function onto the top of the stack. The stack can only add new entries to the top. 
2. Pop: removes or pops a new function off of the top of the stack. The Stack can only remove new entries from the top.
- Last In First Out (LIFO) is a term that summarizes how the call stack works. The last operation that went in is the first operation that will leave the stack.
- After the JavaScript Engine receives JavaScript code, it parses the code and places the first function it encounters on the call stack. If, while executing that function, the JavaScript engine notices that it calls other functions, then those functions are stacked on top of the call stack. This is very important for functions nested in other functions as well as recursive functions.
- For the stack to pop off a function, the engine must have finished interpreting and running that function. If not, it remains there.
- even though JavaScript is single-threaded, it is also asynchronous.
- whenever JavaScript encounters asynchronous instructions like requests to third-party sites, or timer-based actions, it seeks assistance. To achieve this, JavaScript uses the browser’s provided Web Application Programming Interfaces (Web APIs).
- One very important reason for writing asynchronous code = is to prevent a scenario where a particular running function ends up blocking the rest of the code. If this happens, it can cause undesirable user experiences and make our software inefficient.
- The Web APIs = are a set of functions provided by the browser that the JavaScript engine can utilize. They include examples such as Document Object Model (DOM) manipulation methods, fetch, setInterval, setTimeout, promises, async-await functions, and more.
- Asynchronous operations provide a response after being processed using Web APIs. 
- The purpose of writing an asynchronous function is to utilize the function's output for subsequent operations. We refer to the functions that rely on the response from asynchronous operations as callback functions.
- a callback function = is passed in as an argument to an asynchronous function and only runs when the asynchronous operation has been completed
- Callback Queue in browser’s JavaScript Runtime = is a software mechanism that stores callback functions to be run after the Web APIs have processed asynchronous functions. It uses the queue data structure which works with the First In First Out (FIFO) approach. means that the first callback added to that queue is going to be the first callback to leave.
- The event loop = is a loop that continuously checks if the call stack is empty. When the call stack is not empty, it allows the ongoing process to continue. But when the call stack becomes empty, the event loop fetches the task at the top of the callback queue and adds it to the call stack.
- The event loop runs continuously as long as the program is running, always performing its function until the callback queue is completely empty. This is why the JavaScript Engine executes callbacks only after everything in the call stack has been processed.
- promises = There are a few asynchronous features in JavaScript, and one of them is Promises.
- nested callbacks led to the ‘Callback Pyramid of Doom’ or callback hell, which can quickly become a nightmare. So JavaScript introduced Promises as part of ES6 (ES2015) to solve this problem.
- A promise is an assurance or guarantee that something will happen in the future. In JavaScript, a Promise is an object that will produce a single value some time in the future. If the promise is successful, it will produce a resolved value, but if something goes wrong then it will produce a reason why the promise failed.
- JavaScript promises can be in one of three possible states. These states indicate the progress of the promise. They are:
1. pending: This is the default state of a defined promise
2. fulfilled: This is the state of a successful promise
3. rejected: This is the state of a failed promise
- A promise goes from pending to fulfilled, or from pending to rejected
- ‘fulfilled’ and ‘rejected’ indicate the end of a promise. 
- resolve = In promises, resolve is a function with an optional parameter representing the resolved value.
- reject = is a function with an optional parameter representing the reason why the promise failed.
- To create a callback for a promise, you need to use the .then() method. 
.then() method = takes in two callback functions. The first function runs if the promise is resolved, while the second function runs if the promise is rejected.
- When you handle a promise with the .then() method, the operation always returns another promise.
- To handle errors in Promises, use the .catch() method. If anything goes wrong with any of your promises, this method can catch the reason for that error.
- .catch() method = agr promise reject hojaaye to error ko handle krleta hai, aur eik naya fulfilled promise return krta hai with undefined value agr aapne kch return nhi kia. Mtlb reject hone waala promise .catch() ke baad fulfilled ban jaata hai
- You can also use the .catch() method in a chain of promises. It catches the first error it encounters in the chain.
- You can also use .catch() to check for errors in a group of promises before proceeding with further asynchronous operations. It addresses any errors in a promise without requiring the nesting of error callback functions.
- .finally() = To chain an asynchronous operation to a promise regardless of if the promise is resolved or not, use this method. Bcuz sometimes you might want an operation to run no matter what happens to earlier promises. It is for operations you must run whether there is an error or not.
- Promise ke reject hone ka matlab error throw karna nahi hota, lekin agar tum us rejection ko handle nahi karte, to JS warning/error throw kar deta hai. isliye promise rejection ko hamesha handle krna chahiye .catch() se wrna runtime error milega
- It is possible to run more than one promise at a time, means you could have multiple promises that run in parallel. Here are the available methods that can help us achieve this:
1. Promise.all() = argument mein array of promises leta hai aur return krta hai eik single promise, agr diye gaye saare promises fulfilled hogaye to wo single promise eik array of values resolve krta hai jis mein diye gaye har promise ki resolve value hoti hai. Input array mein agr eik bhi promise resolve naa ho to promise.all() rejected promise return krta hai with a reason. Reason for rejection jo first rejected promise ka hota hai wohi same rehta hai. promise.all() saare input promises ko run krta hai uske baad hi kch return krta hai, aur ye sb promises ko eik sth run krta hai isiliye input array mein jo promise sbse zaada time lagaata hai utna hi time promise.all() leta hai sbko run krne mein 
2. Promise.race() = bhi array of promises leta hai as an argument, aur fastest promise return krta hai chaahe resolve ho ya reject bs jis promise ka execution time sbse shortest ho us single promise ko return krdega. Ye method bhi promises ko eik sth run krta hai parallel. Agr rejected promise sbse fastest ho to ye isi ko return karega with the reason. Ye method wahan useful hai jahan ham list of asynchronous operations run karen but hamein sirf fastest executed operation ka result chahiye ho
3. Promise.any() = ye bhi array of promises leta hai as an argument aur us array mein se first resolved promise ko return krta hai yaani wait krta hai kisi bhi promise ke resolve hone ka aur immediately usko return krdeta hai as the output. Agr koi bhi promise resolved naa ho to promise.any() rejected promise return krta hai jis mein array hota hai with reason of rejection of all promises individually, error.stack jis mien aggeragtion error dikhta hai aur error.message bhi hota hai. Ye method wahan useful hai jb hamein asynchronous operations mein se fastest resolved promise chahiye ho
4. Promise.allSettled() = ye method es2020 ki release ke sth JS promises ka feature bana jo sb promises ko eik sth handle krte hai baaqi methods ki tarh. Ye bhi array of promises leta hai as an argument aur return krta hai eik single promises jo hamesha resolve ya fulfilled state mein hota hai, input array mein koi bhi promise rejected ho tb bhi is method ko koi farq nhi prta ye fulfilled promise hi retun karega chaahe sb promise reject hojaayen. ye method array of objects ke sth resolve hota hai jis mein input promises ka status aur resolved promises ki value wrna rejected promises ka reason hota hai. Is ko use krne se hamein apne tamam promises ka overview milta hai kisne kia kaam kia
- Job queue = also known as microtask queue jo asal mein js runtime ka component nhi tha but jb promises js ka part banay tb iski bhi need pargai
- in javascript, promise baaqi async implementtions se fast kaam krta hai aur fast hota hai. ye to ham prh chuke ke event loop async operations ko handle krta hai aur async instructions ke callback functions ko jbhi call kr skta hai jb callstack empty ho. But JS runtime mein ye 2 queues hote hain: callback (ya macrotask) queue, aur job (ya microtask) queue. Callback queue mein saare functions ko call krne se pehle event loop job queue mein saare functions ko call krta hai aur promise ka callback job queue mein rehta hai so event loop isko pehle call krta hai. Isi liye promises baaqi sb async implementation se zaada fast values return krte hain
- promise undefined tb return karta hai jab hamne callback se koi value return nahi ki ho. Ye bs .then() ka return value hai
- Important Rules:
1. .then() Hamesha Ek Naya Promise Return Karta Hai
2. Agar .then() me return karo → wo value next promise ka result ban jaati hai 
3. Agar kuch return na karo → wo undefined ban jata hai
4. .catch() Bhi Ek Naya Promise Return Karta Hai, aur error handle karke promise ko fulfill kar deta hai.
5. Even agar promise turant resolve ho jaye, .then() ka callback tb bhi baad mein chalega (microtask queue me).
- Master Formula (Yaad Rakhne Wala Shortcut)
Banana: new Promise((resolve, reject) => {...})
Fulfill: resolve(value)
Reject: reject(reason)
Consume: .then(result => ...) .catch(error => ...)
Chain: Hamesha return karo agar aagay use karna hai.

Day 33 - Fetch API
Topics: Making HTTP requests, handling responses, JSON parsing.
- free apis list = https://free-apis.github.io/#/categories
- base url = saare links is se shuru hongay
- browser pr ham koi bhi link paste krte hain to ye hamein data laake return krdeta hai jese google.com likhne pr google ka homepage aajata hai but agr hamein yehi kaam JS mein krna ho to iske liye ham fetch api use krte hain data bhejne aur recieve krne ke liye jo Request aur Response objects ka use krti hai
- fetch api ka mtlb hai fetch method ko use krna jo data fetch krne ke kaam aata hai ham url dete hain isko aur ye direct data get krke eik promise return krta hai:
fetch(url, [options])
- status 200 = mtlb successful request
- jb bhi ham fetch method ko koi bhi options nhi dete, to ye by default GET request krta hai yaani data get krta hai
- AJAX = is asynchronous JS & XML, pehle zamaane mein jb bhi data hamare paas aata tha wo xml format mein aata tha aur ab json format mein aata hai 
- JSON = javascript object notation, javascript object ki tarh hota nhi hai sirf dikhaayi deta hai us jesa
- json() method = asynchronous method hai, JSON ko javascript object mein convert krta hai aur promise return krta hai, in short data ko readable form mein banaata hai
- HTTP verbs = http (hyper text transfer protocol) request methods like GET, POST, DELETE, PUT, PATCH etc. bht zaada hain lekin mostly yehi use hote hain, PUT use hota hai agr saare data ko change krna ho update krna ho aur PATCH use hota hai jb kch modifications krni hon
- protocol = means rules
- status codes = ye response obj mein hote hain aur code ke through bataate hain ke request ka kesa response raha, generally 200s ka mtlb hai successful, 400s ka mltb hai client side error, 404 means page not found, 500s is server error
- http headers = ye request aur response dono ke sth hote hain ham bhej bhi skte hain aur hamein recieve bhi hota hai, ye basically extra information hoti hai jese content ka type kia hai, status code wagera